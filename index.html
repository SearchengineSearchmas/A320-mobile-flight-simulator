<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>A320 Extreme - Vanilla Engine</title>
    <style>
        body { margin: 0; overflow: hidden; background: #00050a; color: #00ff41; font-family: 'Segoe UI', sans-serif; }
        canvas { display: block; }
        
        #hud-container {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; border: 20px solid transparent; box-sizing: border-box;
        }

        /* Glass Cockpit HUD */
        #pfd {
            position: absolute; bottom: 40px; left: 50%; transform: translateX(-50%);
            width: 350px; height: 180px; background: rgba(0, 10, 20, 0.85);
            border: 2px solid #333; border-top: 5px solid #555; border-radius: 4px;
            display: flex; justify-content: space-around; align-items: center; padding: 10px;
        }

        .instrument { text-align: center; flex: 1; }
        .digital-readout { font-size: 1.5rem; font-weight: bold; text-shadow: 0 0 10px #00ff41; }
        
        #crash-screen {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            display: none; background: rgba(80, 0, 0, 0.5); z-index: 1000;
        }
    </style>
</head>
<body>

<div id="hud-container">
    <div id="pfd">
        <div class="instrument">
            <div style="font-size: 0.7rem;">SPEED</div>
            <div class="digital-readout">250</div>
            <div style="font-size: 0.6rem;">KNOTS</div>
        </div>
        <div class="instrument" style="border: 1px solid #00ff41; height: 100px; width: 100px; border-radius: 50%; overflow: hidden; position: relative;">
            <div id="horizon-ball" style="position:absolute; width: 200%; height: 200%; top: -50%; left: -50%; background: linear-gradient(to bottom, #0066ff 50%, #663300 50%); transform: rotate(0deg) translateY(0px);"></div>
            <div style="position:absolute; width:100%; height:2px; background:#fff; top:50%;"></div>
        </div>
        <div class="instrument">
            <div style="font-size: 0.7rem;">ALTITUDE</div>
            <div id="alt-val" class="digital-readout">1500</div>
            <div style="font-size: 0.6rem;">FEET</div>
        </div>
    </div>
</div>

<div id="crash-screen">
    <canvas id="blood-canvas"></canvas>
    <div style="position: absolute; top: 40%; width: 100%; text-align: center; color: white; font-size: 3rem; font-weight: bold;">TERRAIN IMPACT</div>
</div>

<canvas id="renderCanvas"></canvas>

<script>
    const canvas = document.getElementById('renderCanvas');
    const ctx = canvas.getContext('2d');

    let width, height;
    let camX = 0, camY = 300, camZ = 0;
    let pitch = 0, roll = 0;
    let speed = 20;
    let isCrashed = false;

    const buildings = [];
    const aiPlanes = [];

    function init() {
        resize();
        // Generate procedural city
        for(let i=0; i<150; i++) {
            buildings.push({
                x: Math.random() * 6000 - 3000,
                y: 0,
                z: Math.random() * -15000,
                w: 60 + Math.random() * 40,
                h: 150 + Math.random() * 400,
                hue: Math.random() * 40 + 200 // Blueish buildings
            });
        }
        // AI Traffic
        for(let j=0; j<8; j++) {
            aiPlanes.push({ x: Math.random()*1000-500, y: 400, z: -Math.random()*8000 });
        }
    }

    function resize() {
        width = canvas.width = window.innerWidth;
        height = canvas.height = window.innerHeight;
    }

    // 3D Projection with Z-Sorting logic
    function project(x, y, z) {
        let tx = x - camX;
        let ty = y - camY;
        let tz = z - camZ;

        // Apply Roll
        let rx = tx * Math.cos(roll) - ty * Math.sin(roll);
        let ry = tx * Math.sin(roll) + ty * Math.cos(roll);

        // Apply Pitch
        let fY = ry * Math.cos(pitch) - tz * Math.sin(pitch);
        let fZ = ry * Math.sin(pitch) + tz * Math.cos(pitch);

        if (fZ >= 0) return null;

        const focal = 700;
        const scale = focal / -fZ;
        return {
            x: (width / 2) + rx * scale,
            y: (height / 2) + fY * scale,
            s: scale
        };
    }

    const keys = {};
    window.onkeydown = e => keys[e.key] = true;
    window.onkeyup = e => keys[e.key] = false;

    function handleCrash() {
        if(isCrashed) return;
        isCrashed = true;
        document.getElementById('crash-screen').style.display = 'block';
        const bc = document.getElementById('blood-canvas');
        const bctx = bc.getContext('2d');
        bc.width = width; bc.height = height;
        let drips = Array(50).fill(0).map(() => ({x: Math.random()*width, y: -50, s: Math.random()*8+4}));
        
        function bloodLoop() {
            bctx.fillStyle = 'rgba(180, 0, 0, 0.3)';
            drips.forEach(d => {
                bctx.beginPath(); bctx.arc(d.x, d.y, 20, 0, Math.PI*2); bctx.fill();
                d.y += d.s;
            });
            requestAnimationFrame(bloodLoop);
        }
        bloodLoop();
        setTimeout(() => location.reload(), 4000);
    }

    function loop() {
        if(isCrashed) return;

        // Flight Physics
        if(keys['ArrowDown']) pitch += 0.015;
        if(keys['ArrowUp']) pitch -= 0.015;
        if(keys['ArrowLeft']) roll -= 0.03;
        if(keys['ArrowRight']) roll += 0.03;

        pitch *= 0.97;
        roll *= 0.94;

        camZ -= speed * Math.cos(pitch);
        camY -= speed * Math.sin(pitch);
        camX += speed * Math.sin(roll);

        // Render
        ctx.fillStyle = '#00050a'; // Dark Night
        ctx.fillRect(0, 0, width, height);

        // Draw Horizon / Sky
        const skyGrad = ctx.createLinearGradient(0, 0, 0, height);
        skyGrad.addColorStop(0, '#000814');
        skyGrad.addColorStop(0.5, '#001d3d');
        skyGrad.addColorStop(1, '#000');
        ctx.fillStyle = skyGrad;
        ctx.fillRect(0,0, width, height);

        // Infinite Recycling & Draw
        buildings.sort((a, b) => b.z - a.z); // Simple Painter's algorithm
        buildings.forEach(b => {
            if (b.z > camZ + 1000) b.z -= 15000;

            let pBase = project(b.x - b.w/2, 0, b.z);
            let pTop = project(b.x + b.w/2, b.h, b.z);

            if(pBase && pTop) {
                const bW = pTop.x - pBase.x;
                const bH = pBase.y - pTop.y;
                
                // Realistic Building Shading
                ctx.fillStyle = `hsl(${b.hue}, 30%, ${Math.min(20, 10000/-b.z * 100)}%)`;
                ctx.fillRect(pBase.x, pTop.y, bW, bH);
                ctx.strokeStyle = `rgba(0, 255, 65, ${0.1 + pBase.s * 0.5})`;
                ctx.strokeRect(pBase.x, pTop.y, bW, bH);
                
                // Windows
                if(pBase.s > 0.5) {
                    ctx.fillStyle = '#ffff0033';
                    ctx.fillRect(pBase.x + bW/4, pTop.y + bH/4, bW/2, 2);
                }
            }

            // Collision
            if(Math.abs(camX - b.x) < b.w && camY < b.h && Math.abs(camZ - b.z) < b.w) handleCrash();
        });

        // HUD Update
        document.getElementById('alt-val').innerText = Math.round(camY * 3);
        const ball = document.getElementById('horizon-ball');
        ball.style.transform = `rotate(${roll * 57.3}deg) translateY(${pitch * 100}px)`;

        if(camY < 10) handleCrash();

        requestAnimationFrame(loop);
    }

    window.onresize = resize;
    init();
    loop();
</script>
</body>
</html>
